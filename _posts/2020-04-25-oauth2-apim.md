---
title: Azure API Management and OAuth 2.0   
date: 2020-04-24 12:00:00 +0000
description: How to add Web App outbound IP addresses into SQL Server firewall using Azure Resource Manager template 
categories: [API Management]
tags: [APIM,Oauth2]
header:
 teaser: "/assets/img/posts/teasers/apiManagement.png"
---
### What is OAuth 2.0 and OpenID Connect?
>OAuth 2.0 is the industry-standard protocol for authorization. OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices. - [oauth.net](https://oauth.net/2/)

Because OAuth 2.0 is an authorization protocol, it leads to the following problems when used for authentication: 
- No standard way to get the user's information
- Every implementation is a little different
- No common set of scope

OpenID Connect is a simple identity layer built on top of the OAuth 2.0 protocol. OAuth 2.0 defines mechanisms to obtain and use access tokens to access protected resources, but it does not specify standard methods to provide identity information. OpenID Connect implements authentication as an extension to the OAuth 2.0 authorization process. It includes information about the end-user in the form of an id_token that verifies the identity of the user and provides basic profile information about the user.

The OpenID Connect flow look like this:

![Desktop View]({{ "/assets/img/posts/aad/OpenIDFlow.png" | relative_url }})

1. A user running browser signs in, enter credentials and consents to permissions.
2. The /oauth2/authorize endpoint returns id_token an authorization code to the browser.
3. The browser redirects to redirect URI (the webserver).
4. The web server validates id_token and sets a session cookie.
5. The web server requests an OAuth bearer token from the /oauth2/token endpoint and provides the authorization code.
6. The /oauth2/token endpoint returns an access token and a refresh_token.
7. The web server calls a web API with a token in the authorization header.
8. The web API validates the token.
9. The web API returns secure data to the webserver.

In OAuth 2.0, the term "grant type" refers to the way an application gets an access token. Each grant type is optimized for a particular use case. Todays best practices for usage of the grant types are: 

- Web application with server backend: authorization code flow
- Native or mobile app: authorization code with PKCE flow
- JavaScript app (Single Page Application) with API backend:
  - authorization code with PKCE flow (if you can)
  - implicit flow (if you must)
- Microservices and APIs: client credentials flow

#### OAuth 2.0 authorization code flow 
OAuth 2.0 authorization code grant uses two separate endpoints. The authorization endpoint is used for the user interaction phase, which results in an authorization code. The token endpoint is then used by the client for exchanging the code for an access token, and often a refresh token as well. Web applications are required to present their application credentials to the token endpoint so that the authorization server can authenticate the client. To authorize access to Azure AD web applications by using the OAuth 2.0 code grant flow, you need to:

1. Register your application with your Azure AD tenant (this provides an Application ID for the application, as well as enable it to receive tokens)
2. Request an authorization code (the authorization code flow begins with the client directing the user to the /authorize endpoint. The client indicates the permissions it needs to acquire from the user)
3. Use the authorization code to request an access token (include the client secret into the request, for security verification)
4. Use the access token to access the resource (add the Authorization: Bearer header in the requests)
5. Refresh the access token

The authorization code flow is illustrated in the picture above, for the Open ID Connect flow. 

#### OAuth 2.0 client cridentials flow 
OAuth 2.0 Client Credentials Grant Flow permits a web service (serving the role of a confidential client) to use its credentials to authenticate when calling another web service instead of impersonating a user. In this scenario, the client is typically a middle-tier web service, a daemon service, or a website. For a higher level of assurance, Azure AD also allows the calling service to use a certificate (instead of a shared secret) as a credential.

The picture illustrates how the client credentials grant flow works in Azure AD.

![Desktop View]({{ "/assets/img/posts/aad/clientCredentialsFlow.png" | relative_url }})

1. The client application authenticates to the Azure AD token issuance endpoint and requests an access token.
2. The Azure AD token issuance endpoint issues the access token.
3. The access token is used to authenticate to the secured resource.
4. Data from the secured resource is returned to the client application.

### Protecting the backend APIs with Azure API Management
When you publish APIs through API Management, it's easy and common to secure access to those APIs by using subscription keys. Developers who need to consume the published APIs must include a valid subscription key in HTTP requests when they make calls to those APIs. The APIM is doing the authorization, and you just need to enable the "Requires subscription" at the product or API level.

The second option is to use client certificates. You can use certificates to provide TLS mutual authentication between the client and the API gateway and configure the API Management gateway to allow only requests with certificates containing a specific thumbprint. The authorization at the gateway level is handled through inbound policies.

The third option, which is of interest in this post, is using OAuth 2.0. With Auth 2.0, the authorization is done in the inbound policy by validating the provided JWT token.  We will take a look at the two applicable flows – authorization code and client credentials.

Note: In the sidebar of API Management Service, under Security, you can see OAuth 2.0 and OpenID Connect options. Those are just for the developer portal, and you don’t need to configure those if you are not using the portal. The same applies to the user authorization option in the settings for the API – it is just to tell the developer portal that needs to supply an access token to use that API. 
It is not clear in the official Microsoft documentation, but the Consumption tier supports OAuth 2.0. Same as above, the documentation refers to the developer portal (because there is no developer portal in Consumption tier). In our demo, we are going to use a consumption tier instance of APIM (1 million API calls per month free of charge ;) )


#### APIM and authorization code flow
For this scenario, we are going to use two .NET core applications:
- Client web application - we will log in to this web application using OpenID, and access the Todo APIs using an access token. You can download the source code of the application [here](https://github.com/tosokr/client-app-todo-api)
- Todo APIs - Web APIs with no built-in protection, exposed via Azure APIM, and protected with OAuth 2.0. I will use the hosted version of the APIs at [https://tosokr-todo-api.azurewebsites.net](https://tosokr-todo-api.azurewebsites.net) If you want, you can download the code from my [Github repository](https://github.com/tosokr/todo-api) and run it locally or host it somewhere else ({your_todo_api}).

As we learned in the OAuth 2.0 authorization code flow section, we need to register our application and API in Azure AD. We will start with the Todo API:
1. In Azure AD, open App Registrations
2. Select "New registration"
3. Under the name, enter Todo API. Select "Accounts in this organizational directory only" for Supported account types and leave Redirect URI empty (because we do not perform authentication from the API, just authorization). Click on "Register"
4. Expose an API by adding a scope like in the picture below. Under "Who can consent?", choose Admin and users (consent is the process of a user granting authorization to an application to access protected resources on their behalf. An admin or user can be asked for consent to allow access to their organization/individual data). In our example, it is OK to enable the user to consent to this application. After creation, copy your scope URI ({your_scope_uri}) and the Application ID URI ({your_application_id_uri})
![Desktop View]({{ "/assets/img/posts/aad/todoApiScope.png" | relative_url }})

Next, register the client application:
1. In Azure AD, open App Registrations
2. Select "New registration"
3. Under the name, enter Client API. Select "Accounts in this organizational directory only" for Supported account types and leave Redirect URI empty (we will add in the next steps). Click on "Register"
4. Copy the values for Application (client) ID ({your_client_id}) and Directory (tenant) ID ({your_tenant_id}), because we will need those later when we will configure the application
5. Select authentication from the sidebar, and click on Add a platform. Select Web and, if you are going to run the application locally, enter the Redirect URIs (I stands for Identifier)  and Logout URLs (L stands for Locator). If you are going to host the application somewhere, enter your URI/Ls. Note that we are enabling the implicit grant for ID tokens because we are using a .NET Core Web Application (as stated in the description).
 ![Desktop View]({{ "/assets/img/posts/aad/clientPermissions.png" | relative_url }}) 
6. Add the https://localhost:44321 (if running the application locally) URI under Redirect URIs. If you are going to run the .NET Core application using Visual Studio Code, also add https://127.0.0.1:44321 and https://127.0.0.1:44321/signin-oidc into the list of URIs.
7. Select Certificates & Secrets and create a new client secret ({your_client_secret}). Copy the value after the creation, because otherwise, you will not be able to see it again.

Next, we need to publish the Todo API in the APIM instance. For simple import, I included a Swagger into the project. You can view it [here](https://tosokr-todo-api.azurewebsites.net/swagger/index.html)
1. Open your API Management service, and under API Management select APIs
2. In Add a new API window, select OpenAPI
3. Fill in the details like in the picture (if you are hosting the Todo API, change the url for the OpenAPI specification) an click Create
 ![Desktop View]({{ "/assets/img/posts/aad/addAPI.png" | relative_url }}) 
4. In the Settings tab of the Todo API, enter the Web Service URL (our backend Todo API), and disable subscription requirement (we are doing a demo)
 ![Desktop View]({{ "/assets/img/posts/aad/setAPISettingsNoAuth.png" | relative_url }})
5. Click on the Todo API, select All operations and open the policy code editor. Copy the xml code bellow, replace the {variables} with your values set in the previous steps, and save it:

```xml
<policies>
  <inbound>
      <base />
      <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid." require-scheme="Bearer">
          <!-- Against which server to do the vaildation -->
          <openid-config url="https://login.microsoftonline.com/{your_tenant_id}/v2.0/.well-known/openid-configuration" />
          <audiences>
              <!-- The provided token is intended for the Todo API -->
              <audience>{your_application_id_uri}</audience>
          </audiences>
          <issuers>
              <!-- List of acceptable issuers of the token -->
              <issuer>https://login.microsoftonline.com/{your_tenant_id}/v2.0</issuer>
              <issuer>https://sts.windows.net/{your_tenant_id}/</issuer>
          </issuers>
          <required-claims>
              <!-- Scope of the token (operation that is allowed) -->
              <claim name="scp" match="all">
                  <value>Todo.All</value>
              </claim>
              <!-- Application that is forwarding the token -->
              <claim name="appid" match="all">
                  <value>{your_client_id}</value>
              </claim>
          </required-claims>
      </validate-jwt>
      <set-header name="Authorization" exists-action="delete" />     
  </inbound>
  <backend>
      <base />
  </backend>
  <outbound>
      <base />
  </outbound>
</policies>
```
We can easily extend the access token, by including a groups claim. After the extension, in the APIM policy we can configure authorization based on group membership, by adding the groups claim. Follow this [link](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-optional-claims) to learn more how to add the optional claims into the token.

Now, if we test the API, we will get a "401 Unauthorized. Access token is missing or invalid." error because the API now requests a valid Bearer token in the Authorization header.

Clone the [repository](https://github.com/tosokr/client-app-todo-api) of the client web application, open the appsetings.json file, overwrite with the content from below and fill in the details for your deployment:
```json
{
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "Domain": "[Enter the domain of your tenant, e.g. contoso.onmicrosoft.com]",
    "TenantId": "{your_tenant_id}",
    "ClientId": "{your_client_id}",
    "CallbackPath": "/signin-oidc",
    "SignedOutCallbackPath ": "/signout-callback-oidc",

    // To call an API
    "ClientSecret": "{your_client_secret}"
  },
  "TodoList": {
    /*
      TodoListScope is the scope of the  API you want to call. 
    */
    "TodoListScope": "{your_scope_uri}", 
    "TodoListBaseAddress": "https://{your_apim_instance_name}.azure-api.net/todo" 

  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```
To run the application, we need .NET Core 3.1. To run the application locally, in the root folder of the application, execute:
```console
dotnet run
```
Navigate to https://localhost:44321, accept the invalid certificate, and login with a user from your Azure Active Directory tenant. After the successful login, you will get the following message to give the application permission to access your data:
![Desktop View]({{ "/assets/img/posts/aad/persmissionRequested.png" | relative_url }})

After you click on Accept, in the top menu (click Accept if a message is displayed) select TodoList. If authorization is successful, you will see the Todo page where you can create, edit, and delete items from the Todo list. If you see an error, then debug because you now know how the OAuth 2.0 works :)

#### APIM and client credentials flow
For this scenario, we will also use two .NET core applications:
- Client daemon application - console application that will use its credentials to get an access token for authorization at Todo APIs. You can download the source code of the application [here](https://github.com/tosokr/client-app-todo-api)
- Todo APIs (same as in the authorization code flow example) - Web APIs with no built-in protection, exposed via Azure APIM, and protected with OAuth 2.0. I will use the hosted version of the APIs at [https://tosokr-todo-api.azurewebsites.net](https://tosokr-todo-api.azurewebsites.net) If you want, you can download the code from my [Github repository](https://github.com/tosokr/todo-api) and run it locally or host it somewhere else ({your_todo_api}).

First, we will register the Todo API in Azure AD. The registration differs from the one in the authorization code flow example (we need to modify the Manifest file):
1. In Azure AD, open App Registrations
2. Select "New registration"
3. Under the name, enter Todo API Client Credentials Flow. Select "Accounts in this organizational directory only" for Supported account types and leave Redirect URI empty (because we do not perform authentication from the API, just authorization). Click on "Register"
4. Expose an API by adding a scope like in the picture below. After creation, copy your scope URI ({your_scope_uri}) and the Application ID URI ({your_application_id_uri})
![Desktop View]({{ "/assets/img/posts/aad/clientCredentialsFlowExposeAPI.png" | relative_url }})
5. From the sidemenu, open the Manifest, and chage the appRoles json definitions to:
```json
"appRoles": [
        {
            "allowedMemberTypes": [
                "Application"
            ],
            "description": "Daemon apps in this role can consume the web api.",
            "displayName": "DaemonAppRole",
            "id": "7489c77e-0f34-4fe9-bf84-0ce8b74a03c4",
            "isEnabled": true,
            "lang": null,
            "origin": "Application",
            "value": "DaemonAppRole"
        }
    ],
```

Next, we will register the client daemon application:
1. In Azure AD, open App Registrations
2. Select "New registration"
3. Under the name, enter Client Daemon Application. Select "Accounts in this organizational directory only" for Supported account types and leave Redirect URI empty. Click on "Register"
4. Copy the values for Application (client) ID ({your_client_id}) and Directory (tenant) ID ({your_tenant_id}), because we will need those later when we will configure the application
5. Select Certificates & Secrets and create a new client secret ({your_client_secret}). Copy the value after the creation, because otherwise, you will not be able to see it again.
6. For the application to be able to access the API, we need to add the permission to the previously published API. Notice, we are adding application permission, not a delegated permission 
![Desktop View]({{ "/assets/img/posts/aad/clientCredentialsFlowAPIPermissions.png" | relative_url }})
7. Because the application runs as a daemon, it can't display any consent for us to allow access. For this reason, as a tenant admin, we will grant consent for the requested permissions for all account in the tenant by clicking on the button "Grant admin consent for "

In the APIM policy we created for the authorization code flow, we checked for a scp (scope) claim. If we want to reuse the existing published API, we will need to remove that validation because the Bearer token for the client cridentials flow contains roles (from the Manifest we edited before) instead of scope. Because of that, we will publish againt the Todo API, now using different path.
1. Open your API Management service, and under API Management select APIs
2. In Add a new API window, select OpenAPI
3. Fill in the details like in the picture (if you are hosting the Todo API, change the url for the OpenAPI specification) an click Create
 ![Desktop View]({{ "/assets/img/posts/aad/clientCredentialsFlowAddAPI.png" | relative_url }}) 
4. In the Settings tab of the Todo API Client Credentials Flow, enter the Web Service URL (our backend Todo API), and disable subscription requirement (we are doing a demo)
 ![Desktop View]({{ "/assets/img/posts/aad/setAPISettingsNoAuth.png" | relative_url }})
5. Click on the Todo API Client Credentials Flow, select All operations and open the policy code editor. Copy the xml code bellow, replace the {variables} with your values set in the previous steps, and save it:
```xml
<policies>
  <inbound>
      <base />
      <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid." require-scheme="Bearer">
          <!-- Against which server to do the vaildation -->
          <openid-config url="https://login.microsoftonline.com/{your_tenant_id}/v2.0/.well-known/openid-configuration" />
          <audiences>
              <!-- The provided token is intended for the Todo API -->
              <audience>{your_application_id_uri}</audience>
          </audiences>
          <issuers>
              <!-- List of acceptable issuers of the token -->
              <issuer>https://login.microsoftonline.com/{your_tenant_id}/v2.0</issuer>
              <issuer>https://sts.windows.net/{your_tenant_id}/</issuer>
          </issuers>
          <required-claims>
              <!-- Roles the application has -->
              <claim name="roles" match="all">
                    <value>DaemonAppRole</value>
              </claim>
              <!-- Application that is forwarding the token -->
              <claim name="appid" match="all">
                  <value>{your_client_id}</value>
              </claim>
          </required-claims>
      </validate-jwt>
      <set-header name="Authorization" exists-action="delete" />     
  </inbound>
  <backend>
      <base />
  </backend>
  <outbound>
      <base />
  </outbound>
</policies>
```
Clone the [repository](https://github.com/tosokr/client-daemon-todo-api) of the client daemon application, open the appsetings.json file, overwrite with the content from below and fill in the details for your deployment:
```json
{
	"Instance": "https://login.microsoftonline.com/{0}",
	"Tenant": "[Enter the domain of your tenant, e.g. contoso.onmicrosoft.com]",
	"ClientId": "{your_client_id}",
	"ClientSecret": "{your_client_secret}",
	"CertificateName": "[Or instead of client secret: Enter here the name of a certificate (from the user cert store) as registered with your application]",
	"TodoListBaseAddress": "https://{your_apim_instance_name}.azure-api.net/todo/todo-client-credentials-flow",
	"TodoListScope": "{your_application_id_uri}.default"
}
```
To run the application, you need .NET Core 3.1. To run the application locally, in the root folder of the application, execute:
```console
dotnet run
```
If sucessfull, you will see an output like this:
```shell
Token acquired

Web Api result:

id = 1
title = Pick up groceries
owner = Mr.Brown

id = 2
title = Finish invoice report
owner = Mr.Yellow

Press any key to exit
```
That is. We managed to protect the same backend API with OAuth 2.0 using the authorization code and client credentials flow.

### Summary
Use OAuth 2.0 for (Authorization):
- Granting access to your API
- Getting access to user data in other systems

Use OpenID Connect for (Authentication):
- Logging the user in
- Making your accounts available in other systems

For authorizing users in your API, use OAuth 2.0 authorization code flow. You can control the access based on scope, particular users, or group membership.
For authorizing applications in your API, user OAuth 2.0 client credentials flow. You can control access based on the roles you create in API manifest and assign those roles to individual applications.
